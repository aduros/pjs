"use strict";

const estraverse = require("estraverse");
const b = require("ast-types").builders;

function parse (js, replacements) {
    const acorn = require("acorn");
    const ast = acorn.parse(js, {
        ecmaVersion: 2020,
        allowReturnOutsideFunction: true,
        allowAwaitOutsideFunction: true,
    });

    if (replacements) {
        function replace (node) {
            if (node.type == "Identifier" && node.name in replacements) {
                return replacements[node.name];
            }
        }
        estraverse.replace(ast, {
            enter (node, parent) {
                if (node.type == "ExpressionStatement") {
                    if (parent.type == "BlockStatement") {
                        const statements = replace(node.expression);
                        if (statements != null) {
                            const idx = parent.body.indexOf(node);
                            parent.body.splice(idx, 1, ...statements);
                            return estraverse.VisitorOption.Skip;
                        }
                    }
                } else {
                    return replace(node);
                }
            },
        });
    }

    return ast;
}

module.exports = opts => {
    const beforeJs = opts.beforeJs;
    const lineJs = opts.lineJs;
    const afterJs = opts.afterJs;

    const mode = opts.mode;
    const csvHeader = opts.csvHeader;
    const jsonFilter = opts.jsonFilter;
    const markupSelector = opts.markupSelector;
    const textDelimiter = opts.textDelimiter;

    const initConsts = [];
    const initVars = [];

    // Features detected by static analysis
    const implicitRequires = new Set();
    const implicitAssigns = new Set();
    let hasDollar = false;
    let hasCOUNT = false;
    let hasLINES = false;

    function transformAst (ast) {
        estraverse.replace(ast, {
            enter (node) {
                switch (node.type) {
                case "Identifier":
                    if (node.name == "$") {
                        hasDollar = true;

                    } else if (node.name.match(/\$\d+/)) {
                        // Transform $123 to $[123]
                        hasDollar = true;
                        return {
                            type: "MemberExpression",
                            object: {type: "Identifier", name: "$"},
                            property: {type: "Literal", value: parseInt(node.name.substr(1), 10)},
                            computed: true,
                            optional: false,
                        }

                    } else if (node.name == "COUNT") {
                        hasCOUNT = true;

                    } else if (node.name == "LINES") {
                        hasLINES = true;

                    } else {
                        switch (node.name) {
                        // Generated by:
                        // curl https://raw.githubusercontent.com/sindresorhus/builtin-modules/master/builtin-modules.json | pjs --json '*' '`case "${_}":`'
                        case "assert": case "async_hooks": case "buffer": case "child_process":
                        case "cluster": case "console": case "constants": case "crypto": case "dgram":
                        case "dns": case "domain": case "events": case "fs": case "http": case "http2":
                        case "https": case "inspector": case "module": case "net": case "os":
                        case "path": case "perf_hooks": case "process": case "punycode":
                        case "querystring": case "readline": case "repl": case "stream":
                        case "string_decoder": case "timers": case "tls": case "trace_events":
                        case "tty": case "url": case "util": case "v8": case "vm": case "wasi":
                        case "worker_threads": case "zlib":
                            implicitRequires.add(node.name);
                            break;
                        }
                    }
                    break;

                case "UpdateExpression":
                    if (node.argument.type == "Identifier") {
                        implicitAssigns.add(node.argument.name);
                    }
                    break;

                case "AssignmentExpression":
                    if (node.left.type == "Identifier") {
                        implicitAssigns.add(node.left.name);
                    }
                    break;
                }
            }
        });
    }

    let beforeAst;
    if (beforeJs) {
        beforeAst = parse(beforeJs);
        transformAst(beforeAst);
    }

    let lineAst = parse(lineJs || "");
    transformAst(lineAst);

    if (lineAst.body.length > 0) {
        // Replace the last expression statement
        const lastStatement = lineAst.body[lineAst.body.length-1];
        if (lastStatement.type == "ExpressionStatement") {
            const additionalStatements = parse(`
                const _result = LAST_EXPR;
                if (_result === true) {
                    print(_);
                } else if (_result !== false && _result != null) {
                    print(_result);
                }
            `, {
                LAST_EXPR: lastStatement.expression,
            }).body;
            lineAst.body.pop();
            lineAst.body = lineAst.body.concat(additionalStatements);
        }
    }

    let afterAst;
    if (afterJs) {
        afterAst = parse(afterJs);
        transformAst(afterAst);

        if (afterAst.body.length > 0) {
            // Replace the last expression statement
            const lastStatement = afterAst.body[afterAst.body.length-1];
            if (lastStatement.type == "ExpressionStatement") {
                const additionalStatements = parse(`
                    const _result = LAST_EXPR;
                    if (_result != null) {
                        print(_result);
                    }
                `, {
                    LAST_EXPR: lastStatement.expression,
                }).body;
                afterAst.body.pop();
                afterAst.body = afterAst.body.concat(additionalStatements);
            }
        }
    }

    if (hasDollar && !mode) {
        const preamble = parse("const $ = _.split(DELIM)", {
            DELIM: b.literal(textDelimiter),
        }).body;
        lineAst.body = preamble.concat(lineAst.body);
    }

    if (hasCOUNT) {
        const preamble = parse("++COUNT").body;
        lineAst.body = preamble.concat(lineAst.body);
        // initVars.push(b.variableDeclarator(b.identifier("COUNT"), b.literal(0)));
        implicitAssigns.add("COUNT"); // Better error handling this way
    }

    if (hasLINES) {
        const preamble = parse("LINES.push(_)").body;
        lineAst.body = preamble.concat(lineAst.body);
        initConsts.push(b.variableDeclarator(b.identifier("LINES"), b.arrayExpression([])));
    }

    for (const name of implicitRequires) {
        const expr = b.callExpression(b.identifier("require"), [b.literal(name)]);
        initConsts.push(b.variableDeclarator(b.identifier(name), expr));
    }
    for (const name of implicitAssigns) {
        initVars.push(b.variableDeclarator(b.identifier(name), b.literal(0)));
    }

    let iterateJs;
    let iterateOpts;
    switch (mode) {
    case "csv":
        iterateJs = `
            const {eachCsv, print} = require("pjs-tool");
            BEFORE;
        `;

        if (csvHeader) {
            iterateJs += "for await (const _ of eachCsv(process.stdin, {columns: true}))";
        } else {
            iterateJs += "for await (const $ of eachCsv(process.stdin))";
        }
        iterateJs += "{ LINE; }";
        break;

    case "json":
        iterateJs = `
            const {eachJson, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachJson(process.stdin, {filter: JSON_FILTER})) {
                LINE;
            }
        `;
        break;

    case "html":
        iterateJs = `
            const {eachHtml, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachHtml(process.stdin, {selector: MARKUP_SELECTOR})) {
                LINE;
            }
        `;
        break;

    case "xml":
        iterateJs = `
            const {eachXml, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachXml(process.stdin, {selector: MARKUP_SELECTOR})) {
                LINE;
            }
        `;
        break;

    default:
        iterateJs = `
            const {eachLine, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachLine(process.stdin)) {
                LINE;
            }
        `;
        break;
    }

    // Write init consts and vars
    const initStatements = [];
    if (initConsts.length > 0) {
        initStatements.push(b.variableDeclaration("const", initConsts));
    }
    if (initVars.length > 0) {
        initStatements.push(b.variableDeclaration("let", initVars));
    }

    const wrapper = parse(`
        (async function () {
            INIT;
            ${iterateJs}
            AFTER;
        })();
    `, {
        INIT: initStatements,
        BEFORE: beforeAst != null ? beforeAst.body : [],
        JSON_FILTER: jsonFilter != null ? b.literal(jsonFilter) : null,
        MARKUP_SELECTOR: markupSelector != null ? b.literal(markupSelector) : null,
        LINE: lineAst.body,
        AFTER: afterAst != null ? afterAst.body : [],
    });

    const escodegen = require("escodegen");
    return escodegen.generate(wrapper);
}
