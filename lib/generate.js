"use strict";

const estraverse = require("estraverse");
const b = require("ast-types").builders;

function parse (js, replacements) {
    const acorn = require("acorn");
    const ast = acorn.parse(js, {
        ecmaVersion: 2020,
        allowReturnOutsideFunction: true,
        allowAwaitOutsideFunction: true,
    });

    if (replacements) {
        function replace (node) {
            if (node.type == "Identifier" && node.name in replacements) {
                return replacements[node.name];
            }
        }
        estraverse.replace(ast, {
            enter (node, parent) {
                if (node.type == "ExpressionStatement") {
                    if (parent.type == "BlockStatement") {
                        const statements = replace(node.expression);
                        if (statements != null) {
                            const idx = parent.body.indexOf(node);
                            parent.body.splice(idx, 1, ...statements);
                            return estraverse.VisitorOption.Skip;
                        }
                    }
                } else {
                    return replace(node);
                }
            },
        });
    }

    return ast;
}

function replaceLastExpression (nodes) {
    // Remove empty statements and flatten block statements
    let lastExpressionStatement = null, lastExpressionStatementIdx = -1;
    for (let ii = 0; ii < nodes.length; ++ii) {
        const node = nodes[ii];
        if (node.type == "EmptyStatement") {
            nodes.splice(ii--, 1);
        } else if (node.type == "BlockStatement") {
            nodes.splice(ii, 1, ...node.body);
            ii += node.body.length-1; // Skip over the statements in this block
        } else if (node.type == "ExpressionStatement") {
            lastExpressionStatement = node;
            lastExpressionStatementIdx = ii;
        } else {
            lastExpressionStatement = null;
            lastExpressionStatementIdx = -1;
        }
    }

    if (lastExpressionStatement != null) {
        nodes[lastExpressionStatementIdx] = b.variableDeclaration("var",
            [b.variableDeclarator(b.identifier("_result"), lastExpressionStatement.expression)]);
        return true;
    }

    return false;
}

module.exports = opts => {
    const beforeJs = opts.beforeJs;
    const lineJs = opts.lineJs;
    const afterJs = opts.afterJs;

    const mode = opts.mode;
    const csvHeader = opts.csvHeader;
    const jsonFilter = opts.jsonFilter;
    const markupSelector = opts.markupSelector;
    const textDelimiter = opts.textDelimiter;
    const inputStream = opts.inputStream || "process.stdin";

    const initConsts = [];
    const initVars = [];

    // List of AST nodes
    let beforeStatements = [];
    let afterStatements = [];

    // Features detected by static analysis
    const implicitRequires = new Set();
    const implicitAssigns = new Set();
    let hasDollar = false;
    let hasCOUNT = false;
    let hasLINES = false;

    function transformAst (ast) {
        return estraverse.replace(ast, {
            enter (node) {
                switch (node.type) {
                case "Identifier":
                    if (node.name == "$") {
                        hasDollar = true;

                    } else if (node.name.match(/\$\d+/)) {
                        // Transform $123 to $[123]
                        hasDollar = true;
                        const idx = parseInt(node.name.substr(1), 10);
                        return b.memberExpression(b.identifier("$"), b.literal(idx), true);

                    } else if (node.name == "COUNT") {
                        hasCOUNT = true;

                    } else if (node.name == "LINES") {
                        hasLINES = true;

                    } else {
                        switch (node.name) {
                        // Generated by:
                        // curl https://raw.githubusercontent.com/sindresorhus/builtin-modules/master/builtin-modules.json | pjs --json '*' '`case "${_}":`'
                        case "assert": case "async_hooks": case "buffer": case "child_process":
                        case "cluster": case "console": case "constants": case "crypto": case "dgram":
                        case "dns": case "domain": case "events": case "fs": case "http": case "http2":
                        case "https": case "inspector": case "module": case "net": case "os":
                        case "path": case "perf_hooks": case "process": case "punycode":
                        case "querystring": case "readline": case "repl": case "stream":
                        case "string_decoder": case "timers": case "tls": case "trace_events":
                        case "tty": case "url": case "util": case "v8": case "vm": case "wasi":
                        case "worker_threads": case "zlib":
                            implicitRequires.add(node.name);
                            break;
                        }
                    }
                    break;

                case "UpdateExpression":
                    if (node.argument.type == "Identifier") {
                        implicitAssigns.add(node.argument.name);
                    }
                    break;

                case "AssignmentExpression":
                    if (node.left.type == "Identifier") {
                        implicitAssigns.add(node.left.name);
                    }
                    break;

                case "LabeledStatement":
                    switch (node.label.name) {
                    case "BEFORE":
                        beforeStatements.push(transformAst(node.body));
                        return b.emptyStatement();
                    case "AFTER":
                        afterStatements.push(transformAst(node.body));
                        return b.emptyStatement();
                    }
                    break;
                }
            }
        });
    }

    let lineAst = transformAst(parse(lineJs || ""));
    if (replaceLastExpression(lineAst.body)) {
        lineAst.body = lineAst.body.concat(parse(`
            if (_result === true) {
                print(_);
            } else if (_result !== false && _result != null) {
                print(_result);
            }
        `).body);
    }

    if (beforeJs) {
        const ast = transformAst(parse(beforeJs));
        beforeStatements = beforeStatements.concat(ast.body);
    }
    if (replaceLastExpression(beforeStatements)) {
        beforeStatements = beforeStatements.concat(parse(`
            if (_result != null) {
                print(_result);
            }
        `).body);
    }

    if (afterJs) {
        const ast = transformAst(parse(afterJs));
        afterStatements = afterStatements.concat(ast.body);
    }
    if (replaceLastExpression(afterStatements)) {
        afterStatements = afterStatements.concat(parse(`
            if (_result != null) {
                print(_result);
            }
        `).body);
    }

    if (hasDollar && !mode) {
        const preamble = parse("const $ = _.trim().split(DELIM)", {
            DELIM: b.literal(textDelimiter),
        }).body;
        lineAst.body = preamble.concat(lineAst.body);
    }

    if (hasCOUNT) {
        const preamble = parse("++COUNT").body;
        lineAst.body = preamble.concat(lineAst.body);
        // initVars.push(b.variableDeclarator(b.identifier("COUNT"), b.literal(0)));
        implicitAssigns.add("COUNT"); // Better error handling this way
    }

    if (hasLINES) {
        const preamble = parse("LINES.push(_)").body;
        lineAst.body = preamble.concat(lineAst.body);
        initConsts.push(b.variableDeclarator(b.identifier("LINES"), b.arrayExpression([])));
    }

    for (const name of implicitRequires) {
        const expr = b.callExpression(b.identifier("require"), [b.literal(name)]);
        initConsts.push(b.variableDeclarator(b.identifier(name), expr));
    }
    for (const name of implicitAssigns) {
        initVars.push(b.variableDeclarator(b.identifier(name), b.literal(0)));
    }

    let iterateJs;
    let iterateOpts;
    switch (mode) {
    case "csv":
        iterateJs = `
            const {eachCsv, print} = require("pjs-tool");
            BEFORE;
        `;

        if (csvHeader) {
            iterateJs += `for await (const _ of eachCsv(${inputStream}, {columns: true}))`;
        } else {
            iterateJs += `for await (const $ of eachCsv(${inputStream}))`;
        }
        iterateJs += "{ LINE; }";
        break;

    case "json":
        iterateJs = `
            const {eachJson, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachJson(${inputStream}, {filter: JSON_FILTER})) {
                LINE;
            }
        `;
        break;

    case "html":
        iterateJs = `
            const {eachHtml, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachHtml(${inputStream}, {selector: MARKUP_SELECTOR})) {
                LINE;
            }
        `;
        break;

    case "xml":
        iterateJs = `
            const {eachXml, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachXml(${inputStream}, {selector: MARKUP_SELECTOR})) {
                LINE;
            }
        `;
        break;

    default:
        iterateJs = `
            const {eachLine, print} = require("pjs-tool");
            BEFORE;
            for await (const _ of eachLine(${inputStream})) {
                LINE;
            }
        `;
        break;
    }

    // Write init consts and vars
    const initStatements = [];
    if (initConsts.length > 0) {
        initStatements.push(b.variableDeclaration("const", initConsts));
    }
    if (initVars.length > 0) {
        initStatements.push(b.variableDeclaration("let", initVars));
    }

    const wrapper = parse(`
        (async function () {
            INIT;
            ${iterateJs}
            AFTER;
        })();
    `, {
        INIT: initStatements,
        BEFORE: beforeStatements,
        JSON_FILTER: jsonFilter != null ? b.literal(jsonFilter) : null,
        MARKUP_SELECTOR: markupSelector != null ? b.literal(markupSelector) : null,
        LINE: lineAst.body,
        AFTER: afterStatements,
    });

    const escodegen = require("escodegen");
    return escodegen.generate(wrapper);
}
